# 频谱分析算法设计

## 1. 频谱分析架构

### 1.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         频谱分析系统架构                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     输入层 (Input Layer)                             │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐    │   │
│  │  │ 音频采集   │  │ 格式转换   │  │ 重采样     │  │ 预处理     │    │   │
│  │  │ 44.1kHz    │  │ Float32    │  │ (如需要)   │  │ DC去除     │    │   │
│  │  │ 16bit      │  │ 归一化     │  │            │  │ 预加重     │    │   │
│  │  └────────────┘  └────────────┘  └────────────┘  └────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   分析层 (Analysis Layer)                            │   │
│  │                                                                     │   │
│  │   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐         │   │
│  │   │ 短时傅里叶   │    │ 多分辨率     │    │ 瞬时频率     │         │   │
│  │   │ 变换 (STFT)  │    │ 分析 (MRA)   │    │ 估计 (IF)    │         │   │
│  │   │              │    │              │    │              │         │   │
│  │   │ FFT Size:    │    │ 低频: 大窗口 │    │ 相位导数     │         │   │
│  │   │ 4096/8192    │    │ 高频: 小窗口 │    │ 频率精细化   │         │   │
│  │   └──────────────┘    └──────────────┘    └──────────────┘         │   │
│  │                                                                     │   │
│  │   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐         │   │
│  │   │ 梅尔频谱     │    │ 色度频谱     │    │ 倒频谱       │         │   │
│  │   │ (Mel-scale)  │    │ (Chroma)     │    │ (Cepstrum)   │         │   │
│  │   │              │    │              │    │              │         │   │
│  │   │ 人耳感知     │    │ 音高类别     │    │ 基频检测     │         │   │
│  │   │ 频率标度     │    │ 能量分布     │    │ 谐波分析     │         │   │
│  │   └──────────────┘    └──────────────┘    └──────────────┘         │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   输出层 (Output Layer)                              │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐    │   │
│  │  │ 频谱数据   │  │ 频谱图     │  │ 特征向量   │  │ 回调通知   │    │   │
│  │  │ 幅度/相位  │  │ 时频表示   │  │ 用于检测   │  │ UI更新     │    │   │
│  │  └────────────┘  └────────────┘  └────────────┘  └────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心算法实现

### 2.1 多分辨率 FFT 分析器

```cpp
class MultiResolutionSpectrumAnalyzer
{
public:
    struct Config {
        float sampleRate = 44100.0f;
        
        // 多分辨率配置
        struct Resolution {
            int fftOrder;       // FFT 阶数
            float minFreq;      // 适用最低频率
            float maxFreq;      // 适用最高频率
            int hopSize;        // 步长
        };
        
        std::vector<Resolution> resolutions = {
            {13, 20.0f, 250.0f, 256},    // 8192 - 低频高分辨率
            {12, 200.0f, 1000.0f, 512},  // 4096 - 中频
            {11, 800.0f, 4000.0f, 1024}  // 2048 - 高频时间分辨率
        };
    };
    
    struct SpectrumFrame {
        std::vector<float> frequencies;   // 频率轴 (非均匀)
        std::vector<float> magnitudes;    // 幅度谱
        std::vector<float> phases;        // 相位谱
        double timestamp;                 // 时间戳
    };
    
    void prepare(const Config& config);
    void process(const AudioBuffer<float>& input, SpectrumFrame& output);
    
private:
    struct FFTInstance {
        std::unique_ptr<dsp::FFT> fft;
        AudioBuffer<float> window;
        AudioBuffer<float> buffer;
        int hopSize;
        float minFreq;
        float maxFreq;
        int overlapCount = 0;
    };
    
    std::vector<FFTInstance> fftInstances_;
    Config config_;
    
    void mergeSpectrums(const std::vector<SpectrumFrame>& partialResults,
                        SpectrumFrame& output);
};

void MultiResolutionSpectrumAnalyzer::prepare(const Config& config)
{
    config_ = config;
    fftInstances_.clear();
    
    for (const auto& res : config.resolutions)
    {
        FFTInstance inst;
        inst.fft = std::make_unique<dsp::FFT>(res.fftOrder);
        
        int fftSize = 1 << res.fftOrder;
        
        // 创建汉宁窗
        inst.window.setSize(1, fftSize);
        auto* windowData = inst.window.getWritePointer(0);
        for (int i = 0; i < fftSize; ++i)
        {
            windowData[i] = 0.5f - 0.5f * std::cos(2.0f * M_PI * i / (fftSize - 1));
        }
        
        inst.buffer.setSize(1, fftSize * 2);  // FFT 需要 2x 空间
        inst.hopSize = res.hopSize;
        inst.minFreq = res.minFreq;
        inst.maxFreq = res.maxFreq;
        
        fftInstances_.push_back(std::move(inst));
    }
}

void MultiResolutionSpectrumAnalyzer::process(const AudioBuffer<float>& input,
                                               SpectrumFrame& output)
{
    const float* samples = input.getReadPointer(0);
    int numSamples = input.getNumSamples();
    
    std::vector<SpectrumFrame> partialResults;
    
    for (auto& inst : fftInstances_)
    {
        int fftSize = 1 << inst.fft->getSize();
        
        // 应用窗函数
        auto* bufferData = inst.buffer.getWritePointer(0);
        auto* windowData = inst.window.getReadPointer(0);
        
        for (int i = 0; i < fftSize && i < numSamples; ++i)
        {
            bufferData[i] = samples[i] * windowData[i];
        }
        
        // 零填充
        for (int i = numSamples; i < fftSize * 2; ++i)
        {
            bufferData[i] = 0.0f;
        }
        
        // 执行 FFT
        inst.fft->performFrequencyOnlyForwardTransform(bufferData, true);
        
        // 提取频谱 (只取非负频率)
        SpectrumFrame frame;
        int numBins = fftSize / 2 + 1;
        float binWidth = config_.sampleRate / fftSize;
        
        for (int i = 0; i < numBins; ++i)
        {
            float freq = i * binWidth;
            if (freq >= inst.minFreq && freq <= inst.maxFreq)
            {
                frame.frequencies.push_back(freq);
                frame.magnitudes.push_back(bufferData[i]);
            }
        }
        
        partialResults.push_back(std::move(frame));
    }
    
    // 合并各分辨率结果
    mergeSpectrums(partialResults, output);
}

void MultiResolutionSpectrumAnalyzer::mergeSpectrums(
    const std::vector<SpectrumFrame>& partialResults,
    SpectrumFrame& output)
{
    // 按频率排序合并，确保平滑过渡
    std::map<float, float> mergedMagnitudes;
    
    for (const auto& frame : partialResults)
    {
        for (size_t i = 0; i < frame.frequencies.size(); ++i)
        {
            float freq = frame.frequencies[i];
            float mag = frame.magnitudes[i];
            
            // 如果频率已存在，取最大值 (或加权平均)
            auto it = mergedMagnitudes.find(freq);
            if (it == mergedMagnitudes.end() || mag > it->second)
            {
                mergedMagnitudes[freq] = mag;
            }
        }
    }
    
    // 输出到结果结构
    output.frequencies.clear();
    output.magnitudes.clear();
    
    for (const auto& [freq, mag] : mergedMagnitudes)
    {
        output.frequencies.push_back(freq);
        output.magnitudes.push_back(mag);
    }
}
```

### 2.2 瞬时频率估计

```cpp
class InstantaneousFrequencyEstimator
{
public:
    struct Config {
        float sampleRate = 44100.0f;
        int fftSize = 4096;
        int hopSize = 512;
    };
    
    void prepare(const Config& config)
    {
        config_ = config;
        
        // 初始化 FFT
        int order = static_cast<int>(std::log2(config.fftSize));
        fft_ = std::make_unique<dsp::FFT>(order);
        
        // 分配缓冲区
        currentFrame_.setSize(1, config.fftSize * 2);
        previousFrame_.setSize(1, config.fftSize * 2);
        window_.setSize(1, config.fftSize);
        
        // 创建汉明窗
        auto* w = window_.getWritePointer(0);
        for (int i = 0; i < config.fftSize; ++i)
        {
            w[i] = 0.54f - 0.46f * std::cos(2.0f * M_PI * i / (config.fftSize - 1));
        }
        
        isFirstFrame_ = true;
    }
    
    struct FrequencyEstimate {
        float frequency;
        float magnitude;
        float confidence;
    };
    
    std::vector<FrequencyEstimate> estimate(const AudioBuffer<float>& input)
    {
        const float* samples = input.getReadPointer(0);
        
        // 移动旧帧
        std::swap(currentFrame_, previousFrame_);
        
        // 应用窗函数到新帧
        auto* curr = currentFrame_.getWritePointer(0);
        auto* w = window_.getReadPointer(0);
        
        for (int i = 0; i < config_.fftSize; ++i)
        {
            curr[i] = (i < input.getNumSamples()) ? samples[i] * w[i] : 0.0f;
        }
        
        // 执行 FFT 获取相位
        fft_->performRealOnlyForwardTransform(curr, false);
        
        std::vector<FrequencyEstimate> estimates;
        
        if (!isFirstFrame_)
        {
            auto* prev = previousFrame_.getReadPointer(0);
            float binWidth = config_.sampleRate / config_.fftSize;
            
            for (int k = 1; k < config_.fftSize / 2; ++k)
            {
                // 提取复数分量
                float currReal = curr[2*k];
                float currImag = curr[2*k + 1];
                float prevReal = prev[2*k];
                float prevImag = prev[2*k + 1];
                
                // 计算当前和前一帧的相位
                float currPhase = std::atan2(currImag, currReal);
                float prevPhase = std::atan2(prevImag, prevReal);
                
                // 计算相位差
                float phaseDiff = currPhase - prevPhase;
                
                // 解卷绕相位差
                while (phaseDiff > M_PI) phaseDiff -= 2.0f * M_PI;
                while (phaseDiff < -M_PI) phaseDiff += 2.0f * M_PI;
                
                // 计算瞬时频率偏差
                float deltaF = phaseDiff / (2.0f * M_PI * config_.hopSize / config_.sampleRate);
                float instantaneousFreq = k * binWidth + deltaF;
                
                // 计算幅度
                float magnitude = std::sqrt(currReal * currReal + currImag * currImag);
                
                // 只保留显著频率成分
                if (magnitude > 0.001f)
                {
                    estimates.push_back({
                        instantaneousFreq,
                        magnitude,
                        1.0f  // 置信度可基于相位连续性计算
                    });
                }
            }
        }
        
        isFirstFrame_ = false;
        return estimates;
    }
    
private:
    Config config_;
    std::unique_ptr<dsp::FFT> fft_;
    AudioBuffer<float> currentFrame_;
    AudioBuffer<float> previousFrame_;
    AudioBuffer<float> window_;
    bool isFirstFrame_ = true;
};
```

### 2.3 梅尔频谱计算

```cpp
class MelSpectrumCalculator
{
public:
    struct Config {
        float sampleRate = 44100.0f;
        int fftSize = 4096;
        int numMelBins = 128;
        float minFreq = 20.0f;
        float maxFreq = 8000.0f;
    };
    
    void prepare(const Config& config)
    {
        config_ = config;
        
        // 计算梅尔滤波器组
        float minMel = freqToMel(config.minFreq);
        float maxMel = freqToMel(config.maxFreq);
        
        // 在梅尔刻度上均匀分布的中心频率
        std::vector<float> melCenters;
        for (int i = 0; i <= config.numMelBins + 1; ++i)
        {
            float mel = minMel + i * (maxMel - minMel) / (config.numMelBins + 1);
            melCenters.push_back(melToFreq(mel));
        }
        
        // 构建滤波器权重矩阵
        int numFFTbins = config.fftSize / 2 + 1;
        melFilterBank_.resize(config.numMelBins, std::vector<float>(numFFTbins, 0.0f));
        
        float binWidth = config.sampleRate / config.fftSize;
        
        for (int melIdx = 0; melIdx < config.numMelBins; ++melIdx)
        {
            float leftFreq = melCenters[melIdx];
            float centerFreq = melCenters[melIdx + 1];
            float rightFreq = melCenters[melIdx + 2];
            
            for (int fftIdx = 0; fftIdx < numFFTbins; ++fftIdx)
            {
                float freq = fftIdx * binWidth;
                
                if (freq >= leftFreq && freq <= centerFreq)
                {
                    // 上升沿
                    melFilterBank_[melIdx][fftIdx] = (freq - leftFreq) / (centerFreq - leftFreq);
                }
                else if (freq > centerFreq && freq <= rightFreq)
                {
                    // 下降沿
                    melFilterBank_[melIdx][fftIdx] = (rightFreq - freq) / (rightFreq - centerFreq);
                }
            }
        }
    }
    
    std::vector<float> compute(const std::vector<float>& magnitudeSpectrum)
    {
        std::vector<float> melSpectrum(config_.numMelBins, 0.0f);
        
        for (int melIdx = 0; melIdx < config_.numMelBins; ++melIdx)
        {
            float sum = 0.0f;
            for (size_t fftIdx = 0; fftIdx < magnitudeSpectrum.size(); ++fftIdx)
            {
                sum += magnitudeSpectrum[fftIdx] * melFilterBank_[melIdx][fftIdx];
            }
            // 对数压缩
            melSpectrum[melIdx] = std::log10(1.0f + sum * 10.0f);
        }
        
        return melSpectrum;
    }
    
    // 获取梅尔频谱对应的频率标签
    std::vector<float> getMelFrequencies() const
    {
        std::vector<float> freqs;
        float minMel = freqToMel(config_.minFreq);
        float maxMel = freqToMel(config_.maxFreq);
        
        for (int i = 0; i < config_.numMelBins; ++i)
        {
            float mel = minMel + (i + 1) * (maxMel - minMel) / (config_.numMelBins + 1);
            freqs.push_back(melToFreq(mel));
        }
        
        return freqs;
    }
    
private:
    Config config_;
    std::vector<std::vector<float>> melFilterBank_;
    
    // 频率到梅尔刻度转换
    static float freqToMel(float freq)
    {
        return 2595.0f * std::log10(1.0f + freq / 700.0f);
    }
    
    // 梅尔刻度到频率转换
    static float melToFreq(float mel)
    {
        return 700.0f * (std::pow(10.0f, mel / 2595.0f) - 1.0f);
    }
};
```

### 2.4 色度频谱 (Chroma) 计算

```cpp
class ChromaCalculator
{
public:
    // 计算12维色度向量 (C, C#, D, D#, E, F, F#, G, G#, A, A#, B)
    std::array<float, 12> compute(const std::vector<float>& magnitudeSpectrum,
                                   float sampleRate, int fftSize)
    {
        std::array<float, 12> chroma = {0.0f};
        std::array<int, 12> counts = {0};
        
        float binWidth = sampleRate / fftSize;
        
        for (size_t i = 0; i < magnitudeSpectrum.size(); ++i)
        {
            float freq = i * binWidth;
            if (freq < 20.0f) continue;
            
            // 转换为 MIDI 音符号
            float midiNote = 69.0f + 12.0f * std::log2(freq / 440.0f);
            
            // 归一化到12音阶
            int pitchClass = static_cast<int>(std::round(midiNote)) % 12;
            if (pitchClass < 0) pitchClass += 12;
            
            // 使用余弦窗口加权 (更重视准确的音高)
            float deviation = midiNote - std::round(midiNote);
            float weight = std::cos(deviation * M_PI) * 0.5f + 0.5f;
            
            chroma[pitchClass] += magnitudeSpectrum[i] * weight;
            counts[pitchClass]++;
        }
        
        // 归一化
        float maxVal = *std::max_element(chroma.begin(), chroma.end());
        if (maxVal > 0.0f)
        {
            for (auto& val : chroma)
            {
                val /= maxVal;
            }
        }
        
        return chroma;
    }
    
    // 获取主音调估计
    struct KeyEstimate {
        int rootNote;       // 0-11 (C到B)
        bool isMinor;       // 是否小调
        float confidence;
    };
    
    KeyEstimate estimateKey(const std::array<float, 12>& chroma)
    {
        // 简单的音调轮廓匹配
        // 大调轮廓: [2, 0, 1, 0, 1, 1, 0, 2, 0, 1, 0, 1] (C大调)
        // 小调轮廓: [2, 0, 1, 1, 0, 1, 0, 2, 1, 0, 0, 1] (A小调)
        
        const std::array<float, 12> majorProfile = {2, 0, 1, 0, 1, 1, 0, 2, 0, 1, 0, 1};
        const std::array<float, 12> minorProfile = {2, 0, 1, 1, 0, 1, 0, 2, 1, 0, 0, 1};
        
        float bestMajorScore = -1.0f;
        float bestMinorScore = -1.0f;
        int bestMajorRoot = 0;
        int bestMinorRoot = 0;
        
        for (int root = 0; root < 12; ++root)
        {
            float majorScore = correlate(chroma, majorProfile, root);
            float minorScore = correlate(chroma, minorProfile, root);
            
            if (majorScore > bestMajorScore)
            {
                bestMajorScore = majorScore;
                bestMajorRoot = root;
            }
            
            if (minorScore > bestMinorScore)
            {
                bestMinorScore = minorScore;
                bestMinorRoot = root;
            }
        }
        
        if (bestMajorScore > bestMinorScore)
        {
            return {bestMajorRoot, false, bestMajorScore};
        }
        else
        {
            return {bestMinorRoot, true, bestMinorScore};
        }
    }
    
private:
    float correlate(const std::array<float, 12>& chroma,
                    const std::array<float, 12>& profile,
                    int shift)
    {
        float sum = 0.0f;
        for (int i = 0; i < 12; ++i)
        {
            int idx = (i + shift) % 12;
            sum += chroma[idx] * profile[i];
        }
        return sum;
    }
};
```

---

## 3. 可视化频谱处理

### 3.1 频谱平滑与降采样

```cpp
class SpectrumVisualizerProcessor
{
public:
    struct Config {
        int numDisplayBands = 128;    // 显示的频带数量
        float minFreq = 20.0f;        // 最低显示频率
        float maxFreq = 8000.0f;      // 最高显示频率
        float smoothingFactor = 0.3f; // 时间平滑系数
        float dbRange = 80.0f;        // 显示动态范围 (dB)
    };
    
    void prepare(const Config& config)
    {
        config_ = config;
        smoothedValues_.assign(config.numDisplayBands, 0.0f);
        
        // 计算对数频率分布的边界
        bandBoundaries_.resize(config.numDisplayBands + 1);
        float logMin = std::log10(config.minFreq);
        float logMax = std::log10(config.maxFreq);
        
        for (int i = 0; i <= config.numDisplayBands; ++i)
        {
            float logFreq = logMin + i * (logMax - logMin) / config.numDisplayBands;
            bandBoundaries_[i] = std::pow(10.0f, logFreq);
        }
    }
    
    std::vector<float> process(const std::vector<float>& frequencies,
                               const std::vector<float>& magnitudes)
    {
        std::vector<float> displayValues(config_.numDisplayBands, 0.0f);
        
        // 将 FFT 结果映射到显示频带
        for (size_t i = 0; i < frequencies.size(); ++i)
        {
            float freq = frequencies[i];
            float mag = magnitudes[i];
            
            // 转换为 dB
            float db = 20.0f * std::log10(mag + 1e-10f);
            
            // 找到对应的显示频带
            int band = findBandForFrequency(freq);
            if (band >= 0 && band < config_.numDisplayBands)
            {
                displayValues[band] = std::max(displayValues[band], db);
            }
        }
        
        // 时间平滑
        for (int i = 0; i < config_.numDisplayBands; ++i)
        {
            smoothedValues_[i] = config_.smoothingFactor * displayValues[i] +
                                 (1.0f - config_.smoothingFactor) * smoothedValues_[i];
        }
        
        // 归一化到 0-1 范围
        std::vector<float> normalized(config_.numDisplayBands);
        float minDb = -config_.dbRange;
        
        for (int i = 0; i < config_.numDisplayBands; ++i)
        {
            normalized[i] = juce::jlimit(0.0f, 1.0f, 
                                         (smoothedValues_[i] - minDb) / config_.dbRange);
        }
        
        return normalized;
    }
    
    // 获取频带中心频率 (用于标签显示)
    std::vector<float> getBandFrequencies() const
    {
        std::vector<float> freqs(config_.numDisplayBands);
        for (int i = 0; i < config_.numDisplayBands; ++i)
        {
            freqs[i] = std::sqrt(bandBoundaries_[i] * bandBoundaries_[i + 1]);
        }
        return freqs;
    }
    
private:
    Config config_;
    std::vector<float> bandBoundaries_;
    std::vector<float> smoothedValues_;
    
    int findBandForFrequency(float freq) const
    {
        for (int i = 0; i < config_.numDisplayBands; ++i)
        {
            if (freq >= bandBoundaries_[i] && freq < bandBoundaries_[i + 1])
            {
                return i;
            }
        }
        return -1;
    }
};
```

---

## 4. 性能优化策略

### 4.1 SIMD 优化

```cpp
// 使用 JUCE SIMD 加速频谱计算
void processSIMD(const float* input, float* output, int numSamples)
{
    using namespace dsp;
    
    using Vec = SIMDRegister<float>;
    constexpr int vecSize = Vec::size();
    
    int i = 0;
    for (; i <= numSamples - vecSize; i += vecSize)
    {
        Vec data = Vec::fromRawPointer(input + i);
        // SIMD 操作
        data = vecMax(data, Vec::getZero());  // 半波整流示例
        data.copyToRawPointer(output + i);
    }
    
    // 处理剩余样本
    for (; i < numSamples; ++i)
    {
        output[i] = std::max(input[i], 0.0f);
    }
}
```

### 4.2 内存优化

- 使用对象池复用 FFT 缓冲区
- 预分配所有需要的内存，避免实时分配
- 使用 `AudioBuffer` 的 `setSize` 时启用 `keepExistingContent = false`

### 4.3 参数建议

| 参数 | 低功耗模式 | 平衡模式 | 高质量模式 |
|-----|-----------|---------|-----------|
| FFT Size | 2048 | 4096 | 8192 |
| Hop Size | 1024 | 512 | 256 |
| Overlap | 50% | 87.5% | 96.9% |
| 显示频带数 | 64 | 128 | 256 |
| 最大频率 | 4000 Hz | 8000 Hz | 20000 Hz |
| CPU 占用 | ~5% | ~15% | ~30% |
