# 多音高检测算法设计 (Polyphonic Pitch Detection)

## 1. 算法架构概览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     多音高检测算法流程                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Input Spectrum                                                             │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Stage 1: 预处理                                                      │   │
│  │  - 噪声门限 (Noise Gate)                                            │   │
│  │  - 频谱平滑 (Spectral Smoothing)                                    │   │
│  │  - 谐波增强 (Harmonic Enhancement)                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Stage 2: 峰值检测 (Peak Detection)                                   │   │
│  │  - 局部最大值检测                                                    │   │
│  │  - 幅度阈值过滤                                                      │   │
│  │  - 峰值精细化 (抛物线插值)                                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Stage 3: 谐波聚类 (Harmonic Clustering)                              │   │
│  │  - 计算峰值间谐波关系                                                │   │
│  │  - 构建谐波图                                                        │   │
│  │  - 图聚类分析                                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Stage 4: NMF 分解 (可选，用于复杂场景)                                │   │
│  │  - 构建频谱模板                                                      │   │
│  │  - 迭代分解                                                          │   │
│  │  - 提取激活矩阵                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Stage 5: 候选评估与验证                                              │   │
│  │  - pYIN 精修                                                        │   │
│  │  - 时序一致性检查                                                    │   │
│  │  - 置信度计算                                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       ▼                                                                     │
│  Output: Pitch Candidates (频率, MIDI音符, 置信度, 谐波数)                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心算法详解

### 2.1 谐波增强预处理

```cpp
class HarmonicEnhancer
{
public:
    void process(const std::vector<float>& input, 
                 std::vector<float>& output,
                 float sampleRate)
    {
        output = input; // 复制原谱
        
        // 谐波乘积谱 (Harmonic Product Spectrum)
        const int harmonics[] = {2, 3, 4, 5};
        for (int h : harmonics)
        {
            for (size_t i = 0; i < input.size() / h; ++i)
            {
                // 将高次谐波的能量累加到基频
                output[i] += input[i * h] * harmonicWeight(h);
            }
        }
        
        // 频谱压缩 (增强弱谐波)
        for (auto& val : output)
        {
            val = std::pow(val, 0.7f); // 压缩系数
        }
    }
    
private:
    float harmonicWeight(int harmonicIndex)
    {
        // 高次谐波权重递减
        return 1.0f / (1.0f + 0.1f * (harmonicIndex - 1));
    }
};
```

### 2.2 峰值检测算法

```cpp
class PeakDetector
{
public:
    struct Peak {
        float frequency;     // 精确频率 (插值后)
        float magnitude;     // 幅度
        int binIndex;        // FFT bin 索引
        float phase;         // 相位
    };
    
    std::vector<Peak> detect(const std::vector<float>& magnitude,
                            float sampleRate, int fftSize,
                            float thresholdDb = -60.0f)
    {
        std::vector<Peak> peaks;
        float threshold = std::pow(10.0f, thresholdDb / 20.0f);
        float maxMag = *std::max_element(magnitude.begin(), magnitude.end());
        
        // 局部最大值检测
        for (int i = 2; i < (int)magnitude.size() - 2; ++i)
        {
            float mag = magnitude[i];
            
            // 阈值检查
            if (mag < threshold * maxMag) continue;
            
            // 局部最大值检查 (5点比较)
            if (mag > magnitude[i-1] && mag > magnitude[i-2] &&
                mag > magnitude[i+1] && mag > magnitude[i+2])
            {
                // 抛物线插值求精确频率
                float alpha = magnitude[i-1];
                float beta = mag;
                float gamma = magnitude[i+1];
                
                float p = 0.5f * (alpha - gamma) / (alpha - 2*beta + gamma);
                float interpolatedBin = i + p;
                float frequency = interpolatedBin * sampleRate / fftSize;
                
                // 插值幅度
                float interpolatedMag = beta - 0.25f * (alpha - gamma) * p;
                
                peaks.push_back({frequency, interpolatedMag, i, 0.0f});
            }
        }
        
        // 按幅度排序
        std::sort(peaks.begin(), peaks.end(),
                  [](const Peak& a, const Peak& b) {
                      return a.magnitude > b.magnitude;
                  });
        
        return peaks;
    }
};
```

### 2.3 谐波聚类算法

```cpp
class HarmonicClustering
{
public:
    struct PitchCandidate {
        float fundamental;      // 基频
        float midiNote;         // MIDI 音符编号
        float confidence;       // 置信度
        std::vector<int> harmonicBins;  // 归属的谐波bin
        float totalEnergy;      // 总能量
    };
    
    std::vector<PitchCandidate> cluster(
        const std::vector<PeakDetector::Peak>& peaks,
        float minFreq, float maxFreq)
    {
        std::vector<PitchCandidate> candidates;
        std::vector<bool> peakUsed(peaks.size(), false);
        
        // 为每个可能的基频创建候选
        for (size_t i = 0; i < peaks.size(); ++i)
        {
            if (peakUsed[i]) continue;
            
            // 尝试以该峰值作为基频
            float f0 = peaks[i].frequency;
            if (f0 < minFreq || f0 > maxFreq) continue;
            
            PitchCandidate candidate;
            candidate.fundamental = f0;
            candidate.midiNote = freqToMidi(f0);
            candidate.harmonicBins.push_back(i);
            candidate.totalEnergy = peaks[i].magnitude;
            peakUsed[i] = true;
            
            // 查找谐波
            for (int h = 2; h <= 8; ++h)
            {
                float harmonicFreq = f0 * h;
                int bestMatch = findBestHarmonicMatch(peaks, harmonicFreq, h);
                
                if (bestMatch >= 0 && !peakUsed[bestMatch])
                {
                    // 验证谐波关系 (频率偏差在容忍范围内)
                    float expectedFreq = f0 * h;
                    float actualFreq = peaks[bestMatch].frequency;
                    float deviation = std::abs(actualFreq - expectedFreq) / expectedFreq;
                    
                    if (deviation < 0.03f) // 3% 容差
                    {
                        candidate.harmonicBins.push_back(bestMatch);
                        candidate.totalEnergy += peaks[bestMatch].magnitude;
                        peakUsed[bestMatch] = true;
                    }
                }
            }
            
            // 计算置信度
            candidate.confidence = calculateConfidence(candidate, peaks);
            
            if (candidate.harmonicBins.size() >= 2) // 至少2个谐波
            {
                candidates.push_back(candidate);
            }
        }
        
        // 按置信度排序
        std::sort(candidates.begin(), candidates.end(),
                  [](const PitchCandidate& a, const PitchCandidate& b) {
                      return a.confidence > b.confidence;
                  });
        
        return candidates;
    }
    
private:
    float freqToMidi(float freq)
    {
        return 69.0f + 12.0f * std::log2(freq / 440.0f);
    }
    
    int findBestHarmonicMatch(const std::vector<PeakDetector::Peak>& peaks,
                              float targetFreq, int harmonicIndex)
    {
        int bestIdx = -1;
        float minDiff = std::numeric_limits<float>::max();
        
        for (size_t i = 0; i < peaks.size(); ++i)
        {
            float diff = std::abs(peaks[i].frequency - targetFreq);
            float tolerance = targetFreq * 0.05f; // 5% 搜索窗口
            
            if (diff < tolerance && diff < minDiff)
            {
                minDiff = diff;
                bestIdx = (int)i;
            }
        }
        
        return bestIdx;
    }
    
    float calculateConfidence(const PitchCandidate& candidate,
                              const std::vector<PeakDetector::Peak>& peaks)
    {
        // 基于以下因素计算置信度:
        // 1. 谐波数量
        // 2. 谐波幅度衰减是否符合预期
        // 3. 频率稳定性 (需要时序信息)
        
        float harmonicScore = std::min((float)candidate.harmonicBins.size() / 6.0f, 1.0f);
        
        // 理想谐波衰减: 1/n
        float decayScore = 0.0f;
        for (size_t i = 0; i < candidate.harmonicBins.size(); ++i)
        {
            int peakIdx = candidate.harmonicBins[i];
            float expectedRatio = 1.0f / (i + 1);
            float actualRatio = peaks[peakIdx].magnitude / peaks[candidate.harmonicBins[0]].magnitude;
            decayScore += 1.0f - std::abs(expectedRatio - actualRatio) / expectedRatio;
        }
        decayScore /= candidate.harmonicBins.size();
        
        return harmonicScore * 0.6f + decayScore * 0.4f;
    }
};
```

### 2.4 时域精修 (pYIN 简化版)

```cpp
class PYINRefiner
{
public:
    // 使用时域自相关对频域检测结果进行精修
    float refinePitch(const AudioBuffer<float>& audioBuffer,
                      float candidateFreq,
                      float sampleRate)
    {
        const int frameSize = audioBuffer.getNumSamples();
        const int minPeriod = static_cast<int>(sampleRate / (candidateFreq * 1.1f));
        const int maxPeriod = static_cast<int>(sampleRate / (candidateFreq * 0.9f));
        
        // 差分函数 (DF)
        std::vector<float> df(maxPeriod + 1);
        const float* samples = audioBuffer.getReadPointer(0);
        
        for (int tau = minPeriod; tau <= maxPeriod; ++tau)
        {
            float sum = 0.0f;
            for (int i = 0; i < frameSize - tau; ++i)
            {
                float diff = samples[i] - samples[i + tau];
                sum += diff * diff;
            }
            df[tau] = sum;
        }
        
        // 累积均值归一化差分函数 (CMNDF)
        std::vector<float> cmndf(maxPeriod + 1);
        float runningSum = 0.0f;
        for (int tau = minPeriod; tau <= maxPeriod; ++tau)
        {
            runningSum += df[tau];
            cmndf[tau] = df[tau] / (runningSum / (tau - minPeriod + 1));
        }
        
        // 寻找最小值 (最佳周期)
        int bestPeriod = minPeriod;
        float minValue = cmndf[minPeriod];
        
        for (int tau = minPeriod + 1; tau <= maxPeriod; ++tau)
        {
            if (cmndf[tau] < minValue)
            {
                minValue = cmndf[tau];
                bestPeriod = tau;
            }
        }
        
        // 抛物线插值精修
        if (bestPeriod > minPeriod && bestPeriod < maxPeriod)
        {
            float alpha = cmndf[bestPeriod - 1];
            float beta = cmndf[bestPeriod];
            float gamma = cmndf[bestPeriod + 1];
            float p = 0.5f * (alpha - gamma) / (alpha - 2*beta + gamma);
            bestPeriod = bestPeriod + p;
        }
        
        return sampleRate / bestPeriod;
    }
};
```

---

## 3. 时序平滑与跟踪

```cpp
class PitchTracker
{
public:
    struct TrackedPitch {
        float midiNote;
        float velocity;
        int age;              // 跟踪时长 (帧)
        int missedFrames;     // 连续未检测到的帧数
    };
    
    void update(const std::vector<PitchCandidate>& currentCandidates)
    {
        // 将当前候选与已有跟踪匹配
        std::vector<bool> matched(currentCandidates.size(), false);
        
        for (auto& tracked : activePitches_)
        {
            float bestDistance = std::numeric_limits<float>::max();
            int bestMatch = -1;
            
            for (size_t i = 0; i < currentCandidates.size(); ++i)
            {
                if (matched[i]) continue;
                
                float distance = std::abs(currentCandidates[i].midiNote - tracked.midiNote);
                if (distance < 0.5f && distance < bestDistance) // 半音容差
                {
                    bestDistance = distance;
                    bestMatch = (int)i;
                }
            }
            
            if (bestMatch >= 0)
            {
                // 更新跟踪
                tracked.midiNote = 0.8f * tracked.midiNote + 0.2f * currentCandidates[bestMatch].midiNote;
                tracked.velocity = currentCandidates[bestMatch].confidence;
                tracked.age++;
                tracked.missedFrames = 0;
                matched[bestMatch] = true;
            }
            else
            {
                tracked.missedFrames++;
            }
        }
        
        // 移除长时间未检测到的音
        activePitches_.erase(
            std::remove_if(activePitches_.begin(), activePitches_.end(),
                          [](const TrackedPitch& p) { return p.missedFrames > 3; }),
            activePitches_.end()
        );
        
        // 添加新检测到的音
        for (size_t i = 0; i < currentCandidates.size(); ++i)
        {
            if (!matched[i] && currentCandidates[i].confidence > 0.7f)
            {
                activePitches_.push_back({
                    currentCandidates[i].midiNote,
                    currentCandidates[i].confidence,
                    1, 0
                });
            }
        }
    }
    
    const std::vector<TrackedPitch>& getActivePitches() const
    {
        return activePitches_;
    }
    
private:
    std::vector<TrackedPitch> activePitches_;
};
```

---

## 4. 性能优化策略

### 4.1 算法复杂度分析

| 阶段 | 复杂度 | 优化策略 |
|-----|-------|---------|
| FFT | O(N log N) | 使用 JUCE 优化实现，考虑使用 FFTW (GPL) |
| 峰值检测 | O(N) | 提前终止，只搜索目标频段 |
| 谐波聚类 | O(K²) | K为峰值数，限制最大峰值数量 |
| pYIN 精修 | O(M²) | M为采样数，只在候选频率附近搜索 |

### 4.2 质量档位设置

```cpp
enum class QualityLevel {
    Fast,       // 快速: 单音检测，无精修
    Balanced,   // 平衡: 多音检测，简化精修
    Accurate    // 精确: 完整多音检测 + pYIN精修
};

struct DetectionProfile {
    int fftOrder;
    int hopSize;
    bool useNMF;
    bool usePYIN;
    int maxPolyphony;
};

DetectionProfile getProfile(QualityLevel level)
{
    switch (level) {
        case QualityLevel::Fast:
            return {11, 1024, false, false, 1};      // 2048 FFT
        case QualityLevel::Balanced:
            return {12, 512, false, true, 4};        // 4096 FFT
        case QualityLevel::Accurate:
            return {13, 256, true, true, 8};         // 8192 FFT
    }
}
```

---

## 5. 参数调优建议

### 5.1 频率检测范围

| 应用场景 | 最低频率 | 最高频率 | 说明 |
|---------|---------|---------|------|
| 男声 | 65 Hz (C2) | 700 Hz | 基频范围 |
| 女声 | 130 Hz (C3) | 1200 Hz | 基频范围 |
| 小提琴 | 196 Hz (G3) | 2000 Hz | 包含高把位 |
| 钢琴 | 27.5 Hz (A0) | 4186 Hz | 全音域 |
| 吉他 | 82 Hz (E2) | 1200 Hz | 标准调音 |

### 5.2 推荐默认参数

```cpp
struct DefaultParams {
    // 检测参数
    static constexpr float MIN_FREQUENCY = 50.0f;
    static constexpr float MAX_FREQUENCY = 2000.0f;
    static constexpr int MAX_POLYPHONY = 6;
    static constexpr float CONFIDENCE_THRESHOLD = 0.65f;
    
    // 分析参数
    static constexpr int FFT_ORDER = 12;        // 4096 samples @ 44.1kHz = 93ms
    static constexpr int HOP_SIZE = 512;        // 11.6ms hop
    static constexpr float OVERLAP = 0.875f;    // 87.5% overlap
    
    // 时序参数
    static constexpr int ONSET_FRAMES = 2;      // 音符起始检测帧数
    static constexpr int OFFSET_FRAMES = 3;     // 音符结束容忍帧数
    static constexpr float PITCH_SMOOTHING = 0.8f;  // 指数平滑系数
};
```
