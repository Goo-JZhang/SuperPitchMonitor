# SuperPitchMonitor 技术可行性分析报告

## 1. 项目概述

### 1.1 产品定位
SuperPitchMonitor 是一款基于 JUCE 框架开发的 Android 端实时频谱分析与音高检测工具，专为音乐演奏者、歌手和音乐教育工作者设计。

### 1.2 核心需求
1. **实时频谱分析**: 实时显示音频信号的频谱分布
2. **快速节奏音高识别**: 在快速演奏/演唱场景下仍能准确识别音高
3. **多音高提取**: 在背景音乐或乐队配合场景下，能同时提取多个不同音高（polyphonic pitch detection）
4. **Android 平台**: 主要面向移动端的便携使用场景

---

## 2. 技术可行性评估

### 2.1 JUCE 框架适配性分析

#### 2.1.1 音频处理能力
| 功能模块 | JUCE 支持情况 | 说明 |
|---------|--------------|------|
| 实时音频输入 | ✅ 完整支持 | `juce_audio_devices` 模块提供跨平台音频设备访问 |
| FFT 频谱分析 | ✅ 完整支持 | `juce_dsp::FFT` 提供高性能 FFT 实现 |
| 音频缓冲区管理 | ✅ 完整支持 | `AudioBuffer` 类提供高效的音频数据管理 |
| Android 音频后端 | ✅ 支持 | 支持 AAudio (Android 8.0+) 和 OpenSL ES 回退 |

#### 2.1.2 Android 平台支持
JUCE 对 Android 的支持情况：
- **最低 API Level**: 21 (Android 5.0)
- **推荐 API Level**: 24+ (Android 7.0+) 以获得 AAudio 低延迟支持
- **架构支持**: armeabi-v7a, arm64-v8a, x86, x86_64
- **构建系统**: CMake + Android Studio/Gradle

#### 2.1.3 图形渲染能力
- `juce_graphics`: 2D 图形渲染，支持频谱可视化
- `juce_opengl`: 可选的高性能 OpenGL 渲染
- Android Surface 集成：支持原生 Android UI 与 JUCE Component 混合

### 2.2 核心技术难点分析

#### 2.2.1 快速节奏音高识别
**难点**: 快速演奏时，音符持续时间短，传统 FFT 的时间分辨率不足

**解决方案可行性**:
| 方案 | 原理 | 可行性 | 复杂度 |
|-----|------|--------|--------|
| 短时 FFT + 重叠处理 | 减小 FFT 窗口，增加重叠率 | ⭐⭐⭐⭐⭐ | 低 |
| 瞬时频率估计 | 基于相位变化的频率跟踪 | ⭐⭐⭐⭐ | 中 |
| YIN 算法优化 | 改进的时域自相关算法 | ⭐⭐⭐⭐⭐ | 中 |
| 机器学习辅助 | 神经网络 onset 检测 | ⭐⭐⭐ | 高 |

**推荐方案**: 组合使用短时 FFT + YIN 算法，在时间和频率分辨率之间取得平衡

#### 2.2.2 多音高提取（Polyphonic Pitch Detection）
**难点**: 从混合音频中分离并识别多个同时发出的音高

**技术方案对比**:
| 算法 | 原理 | 多音支持 | 实时性 | 资源占用 |
|-----|------|---------|--------|---------|
| 简单峰值检测 | 找频谱峰值 | 有限 | 优 | 低 |
| Harmonic Product Spectrum | 谐波乘积谱 | 中 | 良 | 低 |
| McLeod Pitch Method | 改进的归一化方差 | 有限 | 优 | 低 |
| pYIN (probabilistic YIN) | 概率 YIN | 有限 | 良 | 中 |
| MELODIA | 基于概率图模型 | 优 | 中 | 高 |
| CREPE (Deep Learning) | 神经网络 | 优 | 中 | 高 |
| NMF (非负矩阵分解) | 频谱分解 | 优 | 中 | 中 |

**推荐方案**: 
- 主要算法: **NMF-based Polyphonic Detection** + **峰值聚类**
- 辅助算法: **pYIN** 用于单音验证
- 频谱预处理: **谐波增强** 提升多音分离效果

---

## 3. 技术风险与缓解措施

### 3.1 性能风险
| 风险项 | 风险等级 | 缓解措施 |
|-------|---------|---------|
| Android 设备性能差异大 | 中 | 提供性能档位设置，自适应调整 FFT 大小和帧率 |
| 实时处理延迟过高 | 中 | 使用 AAudio 低延迟模式，优化算法复杂度 |
| 电池消耗过快 | 中 | 智能降频处理，后台时降低采样率 |

### 3.2 算法准确性风险
| 风险项 | 风险等级 | 缓解措施 |
|-------|---------|---------|
| 复杂和声场景识别率低 | 高 | 引入机器学习方法，持续训练优化 |
| 打击乐干扰 | 中 | 频谱预处理，分离瞬态和谐波成分 |
| 低音区频率分辨率不足 | 中 | 使用多分辨率 FFT，低频段加大窗口 |

### 3.3 平台适配风险
| 风险项 | 风险等级 | 缓解措施 |
|-------|---------|---------|
| Android 设备音频延迟差异 | 中 | 延迟校准功能，设备数据库 |
| 不同厂商音频预处理 | 高 | 使用原生音频输入，绕过系统音效 |
| 后台音频限制 | 低 | 申请前台服务权限，用户引导 |

---

## 4. 技术选型结论

### 4.1 核心技术栈
```
框架: JUCE 7.x
语言: C++17
构建: CMake + Android Gradle Plugin
音频: AAudio (主) / OpenSL ES (备用)
DSP: JUCE DSP 模块 + 自定义算法
```

### 4.2 算法架构
```
输入层: Android Audio Capture (AAudio)
    ↓
预处理: 窗函数 → 预加重 → 降噪
    ↓
频谱分析: 多分辨率 FFT (2048/4096/8192 自适应)
    ↓
多音高检测: NMF 分解 + 谐波峰值聚类
    ↓
单音验证: pYIN 精细化校正
    ↓
后处理: 时序平滑 → 八度纠错
    ↓
输出层: 可视化渲染 + MIDI 输出
```

### 4.3 可行性结论

| 维度 | 评估 | 说明 |
|-----|------|------|
| 技术可行性 | ✅ 可行 | JUCE 提供完整支持，算法有成熟方案 |
| 时间可行性 | ✅ 可行 | 3-4 个月可完成 MVP 版本 |
| 资源可行性 | ✅ 可行 | 无需额外硬件，纯软件方案 |
| 性能可行性 | ⚠️ 需优化 | 需在算法复杂度和准确性间平衡 |

**总体结论**: 项目技术可行，建议按阶段实施，优先实现单音实时检测，再迭代多音高提取功能。

---

## 5. 参考资源

### 5.1 学术参考
1. YIN算法: De Cheveigné, A., & Kawahara, H. (2002). "YIN, a fundamental frequency estimator"
2. pYIN: Mauch, M., & Dixon, S. (2014). "pYIN: A fundamental frequency estimator"
3. MELODIA: Salamon, J., & Gómez, E. (2012). "Melody extraction from polyphonic music"
4. CREPE: Kim, J. W., et al. (2018). "Crepe: A convolutional representation for pitch estimation"

### 5.2 开源实现参考
- `aubio`: 轻量级音频分析库 (C)
- `world`: 语音分析合成系统 (C++)
- `torchcrepe`: PyTorch 版 CREPE 实现
